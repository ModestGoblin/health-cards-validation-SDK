// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import log, { LogLevels, logger } from './logger';
import { shcKeyValidator } from './shcKeyValidator';
<<<<<< HEAD
import { FileInfo } from './file';
import { OutputTree } from './error';
import * as healthCard from './healthCard';
import * as jws from './jws-compact';
import * as jwsPayload from './jws-payload';
import * as fhirBundle from './fhirBundle';
import * as qr from './qr';
=======
import verifySchema from './schema';
import { decode } from './qr';
import {FileInfo} from './file';
import {OutputTree, ErrorWithCode, ErrorCode, ErrorItem} from './error';

let _keyStore = JWK.createKeyStore();


const schemas = {
    "HealthCard": './schema/smart-health-card-schema.json',
    "JWS": './schema/jws-schema.json',
    "JWSPayload": './schema/smart-health-card-vc-schema.json',
    "FhirBundle": './schema/fhir-bundle-schema.json'
};

function tryParse<T>(json: string, errorMessage: string): T {
    try {
        return JSON.parse(json) as T;
    } catch {
        throw new ErrorWithCode(errorMessage, ErrorCode.JSON_PARSE_ERROR);
    }
}


export async function parseHealthCard(healthCardText: string): Promise<OutputTree> {

    const output = new OutputTree('SMART Health Card');

    // create an object out of the text, fatal error if fails
    const healthCard = tryParse<HealthCard>(
        healthCardText, "Failed to parse HealthCard data.");

    // check against the schema. execution may continue if schema validation fails
    output.errors = output.errors.concat(await verifySchema(schemas.HealthCard, healthCard));

    if (!healthCard.verifiableCredential) {
        output.info("Critiacal Failure.");
        output.fatal = true;
    }

    if (!(healthCard.verifiableCredential instanceof Array)) {
        output.info("Critiacal Failure.");
        output.fatal = true;
    }

    if (healthCard.verifiableCredential.length === 0) {
        output.info("Critiacal Failure.");
        output.fatal = true;
    }

    if (typeof healthCard.verifiableCredential[0] !== 'string') {
        output.info("Critiacal Failure.");
        output.fatal = true;
    }

    if(output.fatal === true) return output;

    const jwsOutput = await parseJws(healthCard.verifiableCredential[0]);

    output.child = jwsOutput;

    return output;
}

const MAX_JWS_LENGTH = 1195
export async function parseJws(jws: JWS): Promise<OutputTree> {

    const output = new OutputTree('JWS-compact');

    if (jws.length >= MAX_JWS_LENGTH) {
        output.errors.push(new ErrorWithCode('JWS exceeds max character length of ' + MAX_JWS_LENGTH, ErrorCode.JWS_TOO_LONG));
    }

    output.errors = output.errors.concat(await verifySchema(schemas.JWS, jws));

    const verifier = new shcSignatureValidator(_keyStore);
>>>>>>> cp-jws-too-long


function red(text: string) {
    return '\x1b[31m' + text + '\x1b[0m';
}

function formatOutput(outputTree: OutputTree, indent: string): string[] {

    const result = [];

    const errors = outputTree.errors;
    const info = outputTree.infos;

    if (logger.verbosity <= LogLevels.INFO) {

        result.push(indent + outputTree.title);
        indent = '   ' + indent;

        if (errors.length > 0) {
            (info.length > 0 || outputTree.child) ?
                result.push(indent + "├─ " + red('Errors :')) :
                result.push(indent + "└─ " + red('Errors :'));
            const sIndent = (info.length > 0 || outputTree.child) ? '|   ' : '    ';
            for (let i = 0; i < errors.length; i++) {
                const sep = (i < errors.length - 1) ? '├─ ' : '└─ ';
                result.push(indent + sIndent + sep + red(errors[i].message));
            }
            result.push(indent + sIndent);
        }

        if (info.length > 0) {
            (outputTree.child) ? result.push(indent + "├─ Info :") : result.push(indent + "└─ Info :");
            const sIndent = (outputTree.child) ? '|   ' : '    ';
            for (let i = 0; i < info.length; i++) {
                const sep = (i < info.length - 1) ? '├─ ' : '└─ ';
                result.push(indent + sIndent + sep + info[i].message);
            }
            result.push(indent + sIndent);
        }

        if (outputTree.child) result.push(indent + '|');

        return outputTree.child ?
            result.concat(formatOutput(outputTree.child, indent)) :
            result;
    }

    for (let i = 0; i < errors.length; i++) {
        const err = errors[i];
        result.push(red('[' + outputTree.title + ']  ' + err.message + '  [' + err.code.toString() + ']'));
    }

    return outputTree.child ?
        result.concat(formatOutput(outputTree.child, indent)) :
        result;
}


/** Validate the issuer key */
export async function validateKey(key: Buffer): Promise<void> {

    log.debug('Validating key', undefined, key);

    const keyValidator = new shcKeyValidator();

    return keyValidator.verifyHealthCardIssuerKey(key)
        .then(() => { return Promise.resolve(); })
        .catch(err => {
            log.error("Error validating issuer key", undefined, err);
            return Promise.reject();
        });
}

export type ValidationType = "qr" | "qrnumeric" | "healthcard" | "jws" | "jwspayload" | "fhirbundle" | "jwkset";

/** Validates SMART Health Card */
export async function validateCard(fileData: FileInfo, type: ValidationType): Promise<OutputTree> {

    let output: OutputTree | undefined = undefined;

    switch (type.toLocaleLowerCase()) {

    case "qr":
        output = await qr.validate(fileData);
        break;

    case "qrnumeric":
        output = await qr.validate(fileData);
        break;

    case "healthcard":
        // output = await parseHealthCard(fileData.buffer.toString());
        output = await healthCard.validate(fileData.buffer.toString());
        break;

    case "jws":
        // output = await parseJws(fileData.buffer.toString());
        output = await jws.validate(fileData.buffer.toString());
        break;

    case "jwspayload":
        output = jwsPayload.validate(fileData.buffer.toString());
        break;

    case "fhirbundle":
        output = fhirBundle.validate(fileData.buffer.toString());
        break;

    default:
        return Promise.reject("Invalid type : " + type);
    }

    if (output != null) {
        log(formatOutput(output, '').join('\n'), logger.verbosity);
    }

    return output;
}
